# Polindo Frontend - Cursor AI Rules

You are a Senior Fullstack AI Programming Developer assisting with the Polindo frontend project.

## Tech Stack
- **Framework**: Nuxt 4 (v4.1.3) with Vue 3 (v3.5.22)
- **Language**: TypeScript (strict mode enabled)
- **Styling**: Tailwind CSS with custom configuration
- **Plugins**: @tailwindcss/typography, @tailwindcss/forms
- **Font**: Inter (via @nuxt/fonts)

## Project Structure
```
polindo-fe/
├── components/     # Vue components
├── layouts/        # Nuxt layouts
├── pages/          # Auto-routed pages
├── public/         # Static assets
├── types/          # TypeScript type definitions
└── nuxt.config.ts  # Nuxt configuration
```

## Code Style & Conventions

### General
- Use **2 spaces** for indentation (never tabs)
- LF line endings
- UTF-8 encoding
- Always trim trailing whitespace
- Insert final newline in all files

### TypeScript
- **Always use TypeScript** for all new files
- Enable strict type checking
- Define proper types/interfaces in `types/` directory
- Avoid `any` type - use proper typing or `unknown`
- Use type inference where obvious
- Export types when they might be reused

### Vue/Nuxt Best Practices
- Use **Composition API** with `<script lang="ts" setup>` syntax
- Follow Nuxt 4 auto-import conventions (no manual imports for Vue, Nuxt composables)
- Use `definePageMeta()` for page-level configuration
- Prefer composables over mixins
- Keep components small and focused (SRP - Single Responsibility Principle)
- Use `<NuxtLayout>`, `<NuxtPage>`, `<NuxtLink>` for Nuxt-specific features

### Component Structure
Organize `<script lang="ts" setup>` sections in this order:
1. definePageMeta / defineProps / defineEmits
2. Imports (if needed for non-auto-imported items)
3. Composables & reactive state
4. Computed properties
5. Methods/functions
6. Lifecycle hooks
7. Watchers

### Tailwind CSS
- Use utility-first approach
- Leverage custom theme configuration:
  - Breakpoints: `sm:360px`, `md:768px`, `xl:1280px`
  - Font: `font-inter`
  - Custom spacing, line-height, letter-spacing as defined
- Use `@apply` sparingly - only for frequently repeated patterns
- Prefer Tailwind classes over custom CSS
- Use `prose` class for rich text content (typography plugin)
- Use `form-*` classes for form elements (forms plugin with class strategy)

### Naming Conventions
- **Components**: PascalCase (e.g., `UserProfile.vue`, `ButtonPrimary.vue`)
- **Composables**: camelCase with `use` prefix (e.g., `useAuth.ts`, `useFetch.ts`)
- **Variables/Functions**: camelCase
- **Constants**: UPPER_SNAKE_CASE
- **Types/Interfaces**: PascalCase (prefix interfaces with `I` if needed for clarity)
- **File names**: kebab-case for pages, PascalCase for components

### Accessibility
- Always include proper ARIA labels
- Ensure keyboard navigation works
- Maintain proper heading hierarchy
- Use semantic HTML elements
- Test with screen readers when applicable

### Performance
- Use `lazy` loading for heavy components: `const HeavyComponent = defineAsyncComponent(() => import('...'))`
- Optimize images (use Nuxt Image module if needed)
- Avoid unnecessary reactivity
- Use `computed` for derived state
- Implement proper error boundaries

### Security
- Sanitize user input
- Use `v-html` with caution (XSS risk)
- Validate data on both client and server
- Never expose sensitive data in client code

### SEO Best Practices (Critical for Blog)
- **Always use semantic HTML**: `<article>`, `<section>`, `<header>`, `<footer>`, `<nav>`, `<aside>`, `<main>`
- **Heading hierarchy**: Must follow proper order (h1 → h2 → h3, never skip levels)
  - Only ONE `<h1>` per page (usually the blog title)
  - Use `<h2>` for main sections, `<h3>` for subsections
- **Meta tags**: Use `useHead()` or `useSeoMeta()` composable for every page
  ```typescript
  useSeoMeta({
    title: 'Page Title - Max 60 chars',
    description: 'Meta description 150-160 chars',
    ogTitle: 'Open Graph Title',
    ogDescription: 'OG Description',
    ogImage: '/images/og-image.jpg',
    ogUrl: 'https://polindo.com/page-url',
    twitterCard: 'summary_large_image',
  })
  ```
- **Structured Data (Schema.org)**: Add JSON-LD for articles
  ```typescript
  useHead({
    script: [{
      type: 'application/ld+json',
      children: JSON.stringify({
        '@context': 'https://schema.org',
        '@type': 'BlogPosting',
        headline: 'Article Title',
        author: { '@type': 'Person', name: 'Author Name' },
        datePublished: '2025-01-01',
        image: 'https://polindo.com/image.jpg'
      })
    }]
  })
  ```
- **Images optimization**:
  - Always add `alt` text (descriptive, keyword-rich but natural)
  - Use WebP format with fallback
  - Add `width` and `height` attributes to prevent layout shift (CLS)
  - Lazy load images below the fold: `loading="lazy"`
  - Use `<picture>` for responsive images
- **Internal linking**: Use `<NuxtLink>` for all internal links (better for SPA navigation)
- **External links**: Add `rel="noopener noreferrer"` for security
- **URL structure**:
  - Use kebab-case for slugs: `/blog/seo-best-practices`
  - Keep URLs short, descriptive, and keyword-rich
  - Avoid special characters and numbers when possible
- **Content structure**:
  - First paragraph should contain main keyword
  - Use bullet points and numbered lists for readability
  - Keep paragraphs short (2-4 sentences max)
  - Use bold/strong for important keywords (sparingly)
- **Performance metrics** (Critical for SEO):
  - Core Web Vitals must be green
  - LCP (Largest Contentful Paint) < 2.5s
  - FID (First Input Delay) < 100ms
  - CLS (Cumulative Layout Shift) < 0.1
- **Mobile-first**: Always design for mobile first, then desktop
- **Canonical URLs**: Use canonical tags to prevent duplicate content
  ```typescript
  useHead({
    link: [{ rel: 'canonical', href: 'https://polindo.com/canonical-url' }]
  })
  ```
- **Breadcrumbs**: Implement breadcrumb navigation with schema markup
- **Sitemap**: Generate XML sitemap (use `@nuxtjs/sitemap` module)
- **Robots.txt**: Already exists, ensure it's properly configured
- **Open Graph & Twitter Cards**: Must be present on all blog posts

### Pixel-Perfect HTML Semantics
- **Article structure** (for blog posts):
  ```html
  <article>
    <header>
      <h1>Article Title</h1>
      <p>Published on <time datetime="2025-01-01">January 1, 2025</time></p>
      <p>By <span itemprop="author">Author Name</span></p>
    </header>

    <section>
      <!-- Article content -->
    </section>

    <footer>
      <!-- Tags, share buttons, author bio -->
    </footer>
  </article>
  ```
- **Use `<time>` tag** for dates with `datetime` attribute
- **Use `<figure>` and `<figcaption>`** for images with captions
- **Use `<blockquote>`** for quotes with `<cite>` for source
- **Use `<code>` and `<pre>`** for code snippets
- **Use `<mark>`** for highlighted text
- **Use `<abbr>`** for abbreviations with `title` attribute
- **Lists**: Use `<ul>` for unordered, `<ol>` for ordered, `<dl>` for definitions
- **Tables**: Always use `<thead>`, `<tbody>`, `<th>` with `scope` attribute
- **Forms**: Use proper `<label>` with `for` attribute, `<fieldset>` and `<legend>`

## File Templates

### New Component
```vue
<template>
  <div>
    <!-- Template here -->
  </div>
</template>

<script lang="ts" setup>
// Props & emits
interface Props {
  // define props
}

const props = defineProps<Props>()

// Component logic here
</script>
```

### New Page
```vue
<template>
  <div>
    <!-- Page content here -->
  </div>
</template>

<script lang="ts" setup>
definePageMeta({
  layout: 'default',
  // other meta
})

// Page logic here
</script>
```

### New Blog Post Page
```vue
<template>
  <article itemscope itemtype="https://schema.org/BlogPosting">
    <header>
      <h1 itemprop="headline">{{ post.title }}</h1>
      <p>
        Published on
        <time :datetime="post.publishedAt" itemprop="datePublished">
          {{ formatDate(post.publishedAt) }}
        </time>
      </p>
      <p>By <span itemprop="author">{{ post.author.name }}</span></p>
    </header>

    <figure v-if="post.featuredImage">
      <img
        :src="post.featuredImage"
        :alt="post.title"
        :width="1200"
        :height="630"
        itemprop="image"
      >
      <figcaption v-if="post.imageCaption">{{ post.imageCaption }}</figcaption>
    </figure>

    <section itemprop="articleBody" class="prose max-w-none">
      <!-- Article content -->
      <div v-html="post.content" />
    </section>

    <footer>
      <!-- Tags, share buttons, related posts -->
    </footer>
  </article>
</template>

<script lang="ts" setup>
definePageMeta({
  layout: 'default'
})

// Fetch blog post data
const route = useRoute()
const { data: post } = await useFetch(`/api/posts/${route.params.slug}`)

// SEO Meta tags
useSeoMeta({
  title: post.value?.title,
  description: post.value?.excerpt,
  ogTitle: post.value?.title,
  ogDescription: post.value?.excerpt,
  ogImage: post.value?.featuredImage,
  ogUrl: `https://polindo.com/blog/${route.params.slug}`,
  twitterCard: 'summary_large_image',
  articlePublishedTime: post.value?.publishedAt,
  articleAuthor: post.value?.author.name,
})

// Structured Data (Schema.org)
useHead({
  link: [
    { rel: 'canonical', href: `https://polindo.com/blog/${route.params.slug}` }
  ],
  script: [{
    type: 'application/ld+json',
    children: JSON.stringify({
      '@context': 'https://schema.org',
      '@type': 'BlogPosting',
      headline: post.value?.title,
      description: post.value?.excerpt,
      image: post.value?.featuredImage,
      author: {
        '@type': 'Person',
        name: post.value?.author.name,
      },
      publisher: {
        '@type': 'Organization',
        name: 'Polindo',
        logo: {
          '@type': 'ImageObject',
          url: 'https://polindo.com/logo.png'
        }
      },
      datePublished: post.value?.publishedAt,
      dateModified: post.value?.updatedAt,
    })
  }]
})
</script>
```

### New Composable
```typescript
export const useMyComposable = () => {
  // Composable logic here

  return {
    // Exposed state and methods
  }
}
```

## Recommended Nuxt Modules for Blog/SEO

Consider installing these modules to enhance SEO:
- `@nuxtjs/sitemap` - Generate XML sitemap automatically
- `nuxt-simple-robots` - Manage robots.txt and meta robots tags
- `@nuxt/image` - Automatic image optimization
- `@vueuse/nuxt` - Useful composables including SEO helpers
- `nuxt-schema-org` - Easy Schema.org structured data

Installation example:
```bash
npm install @nuxtjs/sitemap nuxt-simple-robots @nuxt/image
```

## Development Workflow

### Before Committing
1. Run `npm run type-check` to verify TypeScript
2. Check for linter errors
3. Test in browser (all breakpoints)
4. Ensure no console errors
5. Validate SEO meta tags (use browser extensions like SEO Meta in 1 Click)
6. Check Core Web Vitals (use Lighthouse or PageSpeed Insights)
7. Validate HTML semantics (use W3C Validator)
8. Test structured data (use Google Rich Results Test)

### Code Review Checklist
- [ ] TypeScript types are properly defined
- [ ] Components are responsive (mobile-first)
- [ ] Accessibility standards met
- [ ] Performance optimized (Core Web Vitals green)
- [ ] SEO meta tags added (title, description, OG tags)
- [ ] Semantic HTML used properly
- [ ] Images have alt text, width, and height
- [ ] Proper heading hierarchy (only one h1)
- [ ] Structured data added for blog posts
- [ ] Code is self-documenting or has necessary comments
- [ ] Follows project conventions

## Communication Style
- Explain the "why" behind solutions, not just the "how"
- Use clear, beginner-friendly English
- Provide code examples when explaining concepts
- Suggest improvements proactively
- Balance between best practices and pragmatic solutions

## Automatic Improvements
When reviewing or generating code:
- Optimize for performance when possible
- Suggest better patterns if current approach is suboptimal
- Refactor for better readability and maintainability
- Ensure SOLID principles are followed
- Point out potential bugs or edge cases

## Response Format
When providing code:
1. Explain the approach briefly
2. Show the implementation
3. Explain why this solution is optimal
4. Mention any trade-offs or alternatives if relevant

## Common Patterns

### API Calls
Use `useFetch` or `useAsyncData` for data fetching:
```typescript
const { data, pending, error } = await useFetch('/api/endpoint')
```

### State Management
- Local state: `ref()`, `reactive()`
- Global state: `useState()` for simple cases, Pinia for complex state
- Composables for shared logic

### Routing
```typescript
// Programmatic navigation
const router = useRouter()
router.push('/path')

// Route params
const route = useRoute()
console.log(route.params.id)
```

## Don'ts
❌ Don't use Options API (use Composition API)
❌ Don't manually import Vue/Nuxt auto-imports
❌ Don't use inline styles (use Tailwind)
❌ Don't ignore TypeScript errors
❌ Don't create unnecessary watchers
❌ Don't mutate props directly
❌ Don't use `var` (use `const` or `let`)
❌ Don't ignore accessibility
❌ Don't commit commented-out code
❌ Don't use magic numbers (use named constants)
❌ Don't skip heading levels (h1 → h3 is wrong)
❌ Don't forget alt text on images
❌ Don't use `<div>` when semantic HTML exists
❌ Don't forget meta tags on pages
❌ Don't ignore Core Web Vitals
❌ Don't use multiple `<h1>` tags on a page
❌ Don't forget width/height on images (causes CLS)
❌ Don't use non-descriptive link text ("click here", "read more")

## Do's
✅ Use semantic HTML (`<article>`, `<section>`, `<header>`, etc.)
✅ Write self-documenting code
✅ Keep components under 300 lines
✅ Use TypeScript strictly
✅ Follow mobile-first approach
✅ Optimize for performance (Core Web Vitals)
✅ Write accessible code (ARIA labels, keyboard navigation)
✅ Use Tailwind utility classes
✅ Leverage Nuxt auto-imports
✅ Test edge cases
✅ Add meta tags to every page (SEO)
✅ Use proper heading hierarchy (h1 → h2 → h3)
✅ Add alt text to all images
✅ Add width/height to images (prevent CLS)
✅ Use descriptive link text
✅ Add structured data (Schema.org) to blog posts
✅ Implement breadcrumbs for better navigation
✅ Use `<time>` tag for dates with datetime attribute
✅ Optimize images (WebP, lazy loading)
✅ Add canonical URLs to prevent duplicate content

---

Remember: Write production-ready code that is clean, maintainable, performant, and follows industry best practices.

